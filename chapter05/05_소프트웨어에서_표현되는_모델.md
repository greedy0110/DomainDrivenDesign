- 이 장의 목표 -> 개별 모델 요소에 초점을 맞추기
- MDD에서 상세한 구현 결정이 얼마나 중요한지 `연관관계`를 토대로 알게 될 것이다.
- 모델을 표현하는 세 가지 패턴 구분에 초점
  - ENTITY 엔티티
  - VALUE OBJECT 값 객체
  - SERVICE 서비스
- 연속성(continuity)과 식별성(identity)이 중요한가? -> ENTITY
- 다른 뭔가의 상태를 기술하는 속성에 불과한가? -> VALUE OBJECT
- 객체보다는 행동이나 연산으로 좀더 명확하게 표현되는가? -> SERVICE
- 이 장을 읽으면 다음과 같은 질문에 답할 수 있을 것
  - 연관관계가 무엇인가
  - 모델을 표현하는 패턴은 무엇인가
  - 모듈이 MDD의 모델의 한 부분인 이유는 무엇인가

## 연관관계
- 현실세계의 다대다(many-to-many), 양방향(bidirectional)관계는 구현과 유지보수를 복잡하게 한다. 또한 이런 관계가 도메인의 특성에 대해 주는 통찰은 거의 없다.
- 연관관계를 쉽게 다루는 방법
  - 탐색 방향을 부여한다
  - 한정자 추가로 다중성을 줄인다.
  - 중요하지 않은 관계를 제거
- 🌟 가능한 관계를 제약하는 것이 중요하다. 그래야 설계가 단순해진다.
  - 🤔 도메인 전문가와 대화를 나눌 때도 관계를 제약해야 하는건가?
  - 🤔 제약 조건이 많으면 … 의도는 잘 드러내지만 수정은 어려워지는 거 아닐까?
- 연관관계에서 한 방향이 다른 것에 비해 훨씬 의미 있고 중요하다는 점을 포착하는 것
- 도메인 특성 반영해 연관관계를 일관되게 제약하면, 연관관계의 의사전달력이 풍부해지고, 구현이 단순해진다.
- 🌟 연관관계에 대한 제약조건 발견되면 모델과 구현에 포함돼야 한다.

## ENTITY, 엔티티, 참조객체
- 📌 생명주기의 연속성과 식별성에 집중
- 📌 객체의 형태나 구현에 상관없이 각 객체를 구별하는 수단을 정의

- 🌟 연속성과 식별성이 이어지느냐 기준
- ENTITY의 근본적 개념은 *객체의 생명주기 내내 이어지는 추상적인 연속성*
- ENTITY란
  - 해당 객체의 `식별성`으로 정의되는 경우
  - 형태와 내용은 급격하게 변경되도 `연속성`은 유지
  - `식별성` 정의
  - `정체성`에 초점 맞추기
- 🌟 의미에 따라 ENTITY 분류하기
- 언어에 내장된 동일성과는 다르다. (e.g. java의 equals)
- 🌟 식별성은 ENTITY의 의미 있는 속성으로 언어에서 제공되는 자동화된 기능으로 대체 불가능

### ENTITY 모델링
- ENTITY 자체는 객체의 가장 본질적인 특징만으로 정의하기
- 그 밖의 객체는 행위, 속성을 검토해 가장 중심이 되는 ENTITY와 연관관계에 있는 다른 객체로 옮기기

### 식별 연산의 설계
- 식별에 사용되는 속성은 시스템의 상태(심지어 시스템이 분산되어 있는 경우도)와 관계없이 해당 시스템 내에서 유일할 것
- 식별성을 정의하려면 도메인을 이해해야 한다. 식별성은 모델로부터 나온다.
- 식별성에 관한 문제는 모델의 구체적인 면면에 따라 달라진다.
  - 🙋‍♂ RDB에서 기본키로 사용하는 인조키, 자연키에서 자연키를 설정하려면 도메인의 이해가 필수일 것 같다. 비슷한 차원의 얘기아닐까?
- 유일성이 컴퓨터 시스템 범위를 넘어 적용될 때도 있다. (e.g. 주민등록번호)

## VALUE OBJECT, 값 객체
- 📌 어느 것인지에 관심이 없고, 무엇인지에 대해서만 관심이 있는 요소

- 🌟 사물의 어떤 특징을 묘사, 사물을 서술하는 객체, 개념적 식별성 없음
- 인위적으로 만들어지는 식별성을 도입할 경우 오해하곤 한다.
- VALUE OBJECT는
  - 속성에만 관심이 있다면 VO
  - 속성의 의미를 표현하고 관련 기능 부여
  - 불변적으로 다루기 (immutable)
  - 식별성 부여하지 않기

### VO 설계
- 속성만 같다면, VO 인스턴스 가운데 어떤 것을 사용하는지는 중요하지 않다.
- `복사`, `공유`, `불변성`을 고려해서 설계 단순화, 성능 최적화를 꾀할 수 있다.
- 객체 소유자가 제어하지 못하는 떠돌이 객체에서 발생할 수 있는 문제를 방지하는 방법
  - 전달된 객체를 불변적으로 만들기
  - 객체의 사본을 전달하기
- VO를 성능 최적화하는 다양한 방법 존재
- 복사와 공유 중 어느 것이 더 나은지 구현 환경에 따라 선택
- 공유가 도움이 되는 경우
  - 공간 절약이 중요한 경우
  - 데이터베이스 내 객체 수를 줄이는 것이 중요한 경우
  - 통신 부하가 낮은 경우 (중앙집중형 서버)
  - 공유 객체의 불변성이 엄격하게 지켜지는 경우
- VO가 불변적이면 변경관리는 단순해짐
- 성능 문제로 변경가능하게 하는 경우
  - V가 자주 변경되는 경우
  - 객체 생성, 비용이 비싼 경우
  - V 공유할 일이 별로 많지 않으면 ...
  - 🌟 VALUE 구현이 변경 가능하면, 공유하면 안 된다. VO는 가급적 변하지 않게 설계한다.

### VO를 포함한 연관관계 설계
- 두 VO 간의 양방향 연관관계는 논리적으로 타당하지 않다.

## SERVICE, 서비스
- 🌟 설계가 매우 명확하고 실용적이더라도 개념적으로 어떠한 객체에도 속하지 않은 연산, 사물이 아니다.
- 활동이나 행동
- 서비스는 특정 연산 수행 이외에 의미가 없는 모델 객체로 가장해 나타나곤 한다 (e.g. 의미없는 Manager를 접미사로 붙이는 것)
  - 🙋‍♂️ Manager와 같은 말로 모델을 정의하고 있다면 단순 서비스 아닌지 의심해보자.
- 🌟 필요한 도메인 기능을 ENTITY나 VALUE에서 억지로 맡게 하면 모델에 기반을 둔 객체의 정의가 왜곡되거나 무의미하고 인위적인 객체가 추가될 것이다.
  - 🤔 예시를 생각해볼 필요가 있다. (계산기 서비슬르 만든다면 계산기는 ENTITY도 VO도 아닌 도메인 기능을 제공하는 서비스가 될 것 같다?)
- SERVICE는 순전히 클라이언트에 무엇을 제공할 수 있느냐다
- 주로 활동으로 이름을 짓는다.
- 잘 만들어진 SERVICE
  - 연산이 ENTITY, VO의 일부가 아니라 도메인 개념과 관련됨
  - 인터페이스가 도메인 모델의 외적 요소 측면에서 정의 🤔 모델의 외적 요소 측면?
  - 연산이 상태를 갖지 않느다 -> 클라이언트가 특정 서비스 인스턴스의 이력과는 상관 없이 서비스 사용
    - 🙋‍♂️ stateless server와도 같은가? 클라이언트 입장에서 보는 서버도 service에 해당하네

### SERVICE와 격리된 도메인 계층
- SERVICE는 계층마다 있으니, 도메인 SERVICE와 구분이 중요하다.
- 도메인 SERVICE
- 응용 SERVICE
- 인프라스트럭처 SERVICE
  - e.g. 이메일 시스템과 통지 수단을 캡슐화하는 인터페이스
- 🌟 도메인과 응용 SERVICE의 가장 큰 차이는, 그러한 기능이 도메인에서 의미가 있냐 없냐다.
  - e.g. 은행 업무 도메인에서 스프레드시트 파일 거래 내역 변환 내보내기 기능은 응용 SERVICE라고 볼 수 있는데, 은행 업무 도메인과 내보내는 파일 형식에는 아무런 연관관계가 없기 때문이다.

### 구성 단위
- SERVICE는 다음 용도로도 사용된다.
  - ENTITY와 VO로부터 클라이언트 분리 가능
  - 도메인 계층 인터페이스 구성 단위 제어
- 도메인 SERVICE를 적절히 도입하면 계층 간 경계를 선명하게 하는 데 도움될 수 있다.
- 클라이언트 제어와 융통성 보다 단순한 인터페이스 선호

## MODULE, 모듈, 패키지
- 📌 MODULE은 개념적 관계가 풍부한 모델 요소를 한 곳으로 모아주는 역할

- 🌟 인지적 과부화(cognitive overload) 줄이기
  - 전체에 압도되지 않고 MODULE 내부 세부사항 분석하거나
  - MODULE 내부 세부사항 배제하고 MODULE 간의 관계를 분석하거나
- 🌟 OOP고 DDD고 가장 중요한 `낮은 결합도`, `높은 응집도`는 인지적 과부화를 낮추기 위함이다.
- 모듈로 쪼개지는 것은 코드가 아니라 개념이다.
- 🌟 관계없는 요소를 관계없다고 명확하게 표현할 수록 인지적 과부화를 줄인다.

### 기민한 MODULE
- 모델과 함께 발전해야함
- 하지만 리팩터링에 비용이 많이드는 게 현실, 최소화하는 방법 모색 필요

### 인프라스트럭처 주도 패키지화의 함정
- 📌 높은 응집도/낮은 결합도가 키 포인트다.

- 프레임워크 표준의 예 : 인프라 코드와 UI 코드를 별도의 패키지 그룹에 두는 `LAYERED ARCHITECTURE` 적용 -> 도메인 계층을 물리적으로 자체 패키지 안으로 들어가게 함
- 티어 아키텍처(`TIERED ARCHITECTURE`) : 
  - 모델 객체에 대한 구현을 잘게 나눠 흩어지게 할 수 있음
  - 단일 도메인 객체의 책임을 여러 객체에 걸쳐 퍼뜨리고, 이 객체를 제각기 분리된 패키지에 두는 식으로 티어를 만들기도 한다. 🙋‍♂️ 응집도가 너무 낮은 코드베이스 아닌가?
- 객체의 가장 기본 : 데이터와 해당 데이터를 대상으로 연산을 수행하는 로직을 캡슐화 하기
- 티어를 분리된 패키지에 들어가게 하면?
  - 분할에만 온 정신을 쏟을 수 밖에 없다.

## 모델링 패러다임
- 객체지향 설계가 가장 지배적 패러다임

### 왜 지배적인가?
- 객체 모델링은 개념은 단순하지만, 도메인 지식을 포착할 만큼은 풍부하다.
- 개발자 커뮤니티와 설계 문화 자체가 성숙되었다.