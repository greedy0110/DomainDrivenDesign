- 도메인 객체의 관리 문제는 아래 두 범주
  - 생명주기 동안 무결성 유지
  - 생명주기 관리 복잡성으로 모델이 난해해지는 것 방지
- 세 가지 패턴으로 해결
  - AGGREGATE : 소유권과 경계를 명확히 정의, 객체 간 연관관계 복잡해지는 것 방지, 도메인 객체 무결성 유지에 도움
  - FACTORY : 생명주기의 초기 단계, 내부 구조의 캡슐화
  - REPOSITORY : 생명주기의 중간과 마지막, 인프라를 캡슐화하며 영속 객체를 찾아 조회하는 수단 제공
- FACTORY, REPOSITORY는 도메인에서 나오는 것은 아니지만, 도메인 설계에 중요한 역할을 담당
  - 모델 객체에 쉽게 접근하는 수단을 제공해 MDD 완성

## AGGREGATE 집합체
- 📌 생명주기 전 단계에서 불변식이 유지돼야 할 범위를 표시
- 📌 ENTITY와 VO를 AGGREGATE로 모으고 경계를 정의하기

- 실제 세상의 현실은 모든 것이 얽히고 설킴
- 🌟 소프트웨어 설계에서는 이렇게 복잡한 연관관계가 문제가 된다.
  - 변경의 일관성을 보장하기가 쉽지 않다. 얽힌 모든 객체의 불변식을 만족하기 어렵기 때문
- 경계(boundary) : 무엇이 포함되고 포함되지 않는지 정의
- 루트 : 단 하나만 존재, AGGREGATE에 포함된 특정 ENTITY
- 단순하지만 엄격한 체계
  - 경계 바깥에선 해당 AGGREGATE의 루트만 참조 가능
  - 루트 이외의 ENTITY는 AGGREGATE 내에서만 구분되는 지역 식별성을 가진다.

## FACTORY 팩터리
- 📌 복잡한 객체, AGGREGATE를 생성하는 데 필요한 지식 캡슐화
- 📌 객체의 생성, 재구성이라는 생명주기 전이를 캡슐화
  - 재구성? 일종의 객체 매핑, 예를 들어 ENTITY 객체를 네트워크상으로 전송할 때 직렬화, 역직렬화 하는 과정을 뜻함
  - FACTORY가 object-mapping에게 위임함

- 다음의 캡슐화 제공
  - 생성이 복잡
  - 생성이 내부 구조를 많이 드러내는 경우
- 객체는 그 자체로 복잡하다, 객체 자체 생성 책임까지 맡기는 게 불합리하다.
  - 복잡한 복합 객체 조립하는 일은, 해당 객체가 하는 일과 관련성이 적다. 🙋‍♂️ 이 둘이 하나의 클래스가 관리한다면 낮은 응집도 문제에 빠지겠군, SRP도 위반이고
- 그렇다고 클라이언트가 도메인 객체를 직접 조립하려면
  - 클라이언트가 도메인 객체 내부구조를 이해해야 한다.
  - 클라이언트가 도메인 내부구조에 결합되므로, 도메인 코드 리팩터링이 더욱 어려워진다.
- 🌟 복잡한 객체를 생성하는 일은 도메인 계층의 책임, 하지만 모델을 표현하는 객체에 속하는 것은 아니다.

### FACTORY의 위치 선정
- 루트의 FACTORY METHOD : 이미 존재하는 AGGREGATE에 요소 추가 시 -> 해당 AGGREGATE 루트에 FACTORY METHOD 정의 가능
- 특정 객체의 FACTORY METHOD : 생성된 객체를 소유하지 않고, 다른 객체를 만들어내는 것과 밀접한 관련 있는 특정 객체에 FACTORY METHOD 두기 🤔 무슨 경우여?
- FACTORY 객체, SERVICE : 구상 구현체, 생성 과정의 복잡성과 같은 것을 감추려면 자연스럽진 않지만 ...

### 생성자만으로 충분한 경우
- 직접 생성자 사용이 더 나은 경우가 있다.
- 🌟 FACTORY는 실제로 다형성을 활용하지 않는 간단한 객체를 이해하기 어렵게 만들 수도 있다. 🙋‍♂️ 이 경우 FACTORY 또한 과한 추상화가 될 수 있다.

### 인터페이스 설계
- 두 가지 사항 명심 
  - 각 연산은 원자적 -> FACTORY 생성 실패에 대한 컨벤션 도입하기
  - 자신에게 전달된 인자와 결합된다. -> 입력 매개변수 선택에 따라 의존성 덫이 만들어 질 수 있다.

### 불변식 로직의 위치
- FACTORY의 책임 : 만들어내는 객체, AGGREGATE의 불변식이 충족되도록 보장
- 누구에게 불변식 검사를 맡길 것이냐?
  - 생성물에 위임
  - 팩토리에 두기

## REPOSITORY (리파지터리)
- 객체 생명주기 중간 ENTITY, VO 탐색을 위한 진입점
- 📌 REPOSITORY 패턴은 "도메인과는 무관하지만 복잡한 데이터 조회 기술"을 캡슐화해서 우리를 다시 모델에 집중하게 해주는 개념적 틀

- 객체의 참조를 받아오는 방법
  - 객체 생성
  - 다른 객체를 검색해서 참조 받아오기 (연관관계를 탐색)
- 연관관계 응집성 vs 검색의 분리 🤔 그와 같은 설계의 미묘한 사항?
  - 연관관계 응집성 e.g. Customer 객체가 모든 Order 컬렉션을 가짐
  - 검색의 분리 e.g. Customer ID 필드로 검색해서 DB에서 Order를 찾음
- 재구성(reconstitution) : 저장돼 있는 객체로부터 인스턴스를 만들어 내는 행위
- 🌟 객체를 `질의를 통해 얻는 데이터의 컨테이너`로 여기는 순간, 전체 설계가 MDD가 아니라 데이터 처리 방식으로 나아간다.
- 인프라 레벨에서 도메인 객체의 참조를 쉽게 획득할 수 있게 한다면 ...
  - 클라에서 탐색 가능한 연관관계를 추가하는 등, 모델을 엉망으로 만들 수 있다.
  - AGGREGATE 루트에서 순회하지 않고, 필요한 데이터를 DB에서 그래도 뽑아낼 수 있다.
  - 도메인 로직이 질의와 클라이언트 코드로 들어간다.
  - ENTITY, VO가 단순 데이터 컨테이너로 전락한다.
  - 인프라를 다루는 기술적 복잡함으로 클라가 복잡해진다.
  - 도메인 계층에 대한 개발자의 이해 수준을 낮춰 모델을 도메인 계층과 동떨어진 것으로 만든다.
- AGGREGATE 내부의 객체는 ROOT 이외의 방법으로 참조를 얻는게 불가능해야 한다.
- 📌 REPOSITORY 패턴은 "도메인과는 무관하지만 복잡한 데이터 조회 기술"을 캡슐화해서 우리를 다시 모델에 집중하게 해주는 개념적 틀
- 📌 REPOSTIROY는 메모리상에 해당 타입의 객체로 구성된 컬렉션이 있다는 착각을 불러 일으키는 객체를 만든다.
  - 데이터 저장소 데이터 삽입, 제거 연산 캡슐화
  - 실제 저장소 질의 기술 캡술화
  - 🌟 AGGREGATE 루트에 대해서만 REPOSTIROY를 제공해라
  - 🌟 모든 객체 저장과 접근은 REPOSITORY에 위임해라. 🙋‍♂️ 클라이언트가 모델에 집중하도록 !

### FACTORY와의 관계
- 📌 FACTORY는 새로운 객체를 만들어 낸다. REPOSITORY는 기존 객체를 찾아낸다.

- FACTORY는 객체 생의 초기
- REPOSITORY는 중간 단계와 마지막 단계
- 기술적 관점에서는 REPOSITORY를 FACTORY로 생각할 수 있긴함.