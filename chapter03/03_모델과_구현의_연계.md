- 코드만 봐도 시스템의 목적에 관해 통찰을 얻을 수 있으면 좋겠다.
- 🌟 도메인 주도 설계에서 필요로 하는 모델링 접근법을 알아볼 예정

## MODEL-DRIVEN DESIGN (모델 주도 설계)
- 🌟 코드와 모델이 긴밀하게 연결되며 코드에 의미가 부여되고 모델과 코드가 서로 대응
- 모델과 코드가 느슨하게 연결된다면 모델도, 코드도 따로 관리가 되어야 할 것이고, 이 둘 그리고 둘 간의 대응을 모두 유지하는 것은 비용 대비 효과가 낮다.
- 모델에 대한 중요한 발견은 언제나 설계/구현 과정에 나타나기 때문에 순수하게 이론에만 입각한 모델은 현실성이 없다.
- 설계와 도메인 모델이 대응하지 않으면 모델은 가치가 없어진다.
- MDD에서는 양쪽 모두의 목적을 달성할 단일 모델을 찾고자 한다.
- 순수하게 기술적인 쟁점은 배제한다. 설계상의 각 객체는 모델에 기술한 개념적 역할을 수행하게 된다. 
- 🌟 도메인 모델을 설계에 밀접하게 연관시키는 원칙을 강제하자. (🤔 뭐가 있지)
- 🙋‍♂️ 구현할 때 의사결정 가이드 규칙을 제안하는 것 같다. "도메인 모델을 설계의 방향성, 즉 의사결정의 기준점으로 삼아라."
- 시스템의 코드에서 요구사항 분석까지 개발의 모든 측면에서 `하나의 모델`만 적용해야 한다.

## 모델링 패러다임과 도구 지원
- 모델은 실제적 구현을 고려하며 만들어야 한다. `설계와 구현 기법`을 활용해 코드가 모델을 효과적으로 표현해야 한다. 🙋‍♂️ 2부에서 다룬다고 한다. 기대가 된다.
- 🌟 모델에 개념적으로 직접 대응되는 소프트웨어 도구가 필수적  👉 `객체지향 프로그래밍`, 객체 설계의 진정한 도약은 코드가 모델의 개념을 표현할 때 나온다 🙋‍♂️ 객체에게 책임을 주는 기준도 어떻게 보면 도메인 모델이 그 바로미터가 되야하는 건가 싶다.
- 직접 대응되는 도구를 활용하지 않으면 프로그램이 의미를 전달하기 쉽지않다. 🤔 코드 자체로 의미를 담는다. 이 표현은 ?
- 도메인 개념을 암시적으로 내포하는 코드에서 명시적으로 드러내는 코드로 개선하기
  - 핵심적인 도메인 로직을 테스트할 수 있다.

## 내부 드러내기: 왜 모델이 사용자에게 중요한가
- 인터넷 익스플로러의 즐겨찾기 예시
  - 사용자의 이해(북마크와 웹사이트 URL은 다름)을 설계에 반영하지 않고 북마크를 URL로 다룸
- 문제는 대상이 되는 두 모델이 서로 다르다는 것이다. 🌟 `사용자 모델`과 `설계/구현 모델`이 별도로 존재한다는 것이 문제
- 도메인 전문가의 기본적인 관심사를 반영하는 모델에 기반을 두면, 설계의 골격이 다른 설계 접근법에 비해 사용자에게 잘 드러날 수 있을 것이다. 🤔 과연... 경험해보고 싶다.

## HANDS-ON MODELER (실천적 모델러)
- 도메인 전문가와 소통하고 모델을 만드는 `모델러`, 실제로 구현하는 `프로그래머`
- 둘을 엄격하게 분리하는 건 쓸모가 없었다.
  - 모델의 의도 중 일부가 전달 과정에서 사라짐
  - 모델의 효과는 세부사항에 민감하게 반응할 수 있는데 🤔 뭔 말이냐? 2, 3부에서 논의한다 한다.
  - 모델의 구현과 기술과의 상호작용에 대한 피드백이 간접적
- 코드의 변경이 곧 모델의 변경이라는 점을 개발자가 인식하지 못하면 리팩터링은 모델을 강화하기보다 악화시킬 것
- 🌟 코드를 작성하는 사람이 모델에 책임을 가져야 한다. 그래야 모델과 소프트웨어가 지속적으로 연결되고 유지된다.
  - 좋아하건 말건 프로그래머가 모델러다. 🙋‍♂️ 나도 좋은 모델러가 될 수 있도록 설계에 대한 심도있는 학습이 필요하다.

## 요약 (1부 마무리)
- `도메인 주도 설계`는 `모델`을 동작하게해 `애플리케이션 문제`를 해결
- `지식탐구`를 기반으로 모델을 만든다.
- `MODEL-DRIVEN DESIGN`은 `모델`과 `구현`을 밀접하게 연결
- `UBIQUITOUS LANGUAGE`는 모든 구성요소(개발자, 도메인 전문가, 소프트웨어)사이에 흐르는 `모든 정보의 통로`
- 🚀 결과 👉 핵심 도메인의 근본적인 이해를 토대로 한, 기능이 풍부한 소프트웨어
- MDD 성공은 세부적인 설계 결정에 민감하게 영향을 받는다. (2부에서 다루게 된다)
